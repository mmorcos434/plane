#include <iostream>
#include <vector>
# include <unordered_map>
#include <chrono>
#include "exprtk.hpp"

void max_comp_score() {
    double m1_max;
    double m2_max;
    double m3_max;
    double ground;

    std::vector<double*> mission_scores = { &m1_max, &m2_max, &m3_max, &ground };
    std::vector<std::string> mission_names = { "m1_max", "m2_max", "m3_max", "ground" };

    for (size_t i = 0; i < mission_scores.size(); i++) {
        std::cout << "Put in a value for " << mission_names[i] << ": ";
        std::cin >> *mission_scores[i];
        std::cout << mission_names[i] << " = " << *mission_scores[i] << std::endl;
    }

    std::cout << "Is there Anything Else That Affects Total Score Reply 1 for yes and 2 for no";
    std::string user_response_to_mission_q;
    std::cin >> user_response_to_mission_q;

    while (user_response_to_mission_q == "1") {
        std::string new_parap_name;
        double new_para_val;

        std::cout << "Provide the name of this new parameter: ";
        std::cin >> new_parap_name;

        std::cout << "Provide the value of this new parameter: ";
        std::cin >> new_para_val;

        // make dyanic doub to store var
        double* new_var_ptr = new double(new_para_val);
        mission_scores.push_back(new_var_ptr);
        mission_names.push_back(new_parap_name);

        std::cout << new_parap_name << " = " << new_para_val << std::endl;


        std::cout << "Add another extra parameter? (1 = yes, 2 = no): ";
        std::cin >> user_response_to_mission_q;


        while (user_response_to_mission_q != "1" && user_response_to_mission_q != "2") {
            std::cout << "Invalid input. Please enter 1 (yes) or 2 (no): ";
            std::cin >> user_response_to_mission_q;
        }
    }

    std::cin.ignore();
    std::string total_score_equation;
    std::cout << "Provide the formula to calculate the total mission score: ";
    std::getline(std::cin, total_score_equation);

    // really gonna put exptr to work donw here chat gpt helped out a lot below :)
    exprtk::symbol_table<double> symbol_table;
    exprtk::expression<double> expression;
    exprtk::parser<double> parser;

    for (size_t i = 0; i < mission_scores.size(); ++i) {
        symbol_table.add_variable(mission_names[i], *mission_scores[i]);
    }
    expression.register_symbol_table(symbol_table);

    if (parser.compile(total_score_equation, expression)) {
        double total_score = expression.value();
        std::cout << "Total Mission Score: " << total_score << std::endl;
    }
    else {
        std::cout << "Invalid formula. Please check your syntax." << std::endl;
    }

    for (size_t i = 4; i < mission_scores.size(); ++i) {
        delete mission_scores[i];
    }
}

void find_eq_vars() {
    std::unordered_map<std::string, double> equation_variables_from_user;
    std::cout << "how many variables does this equation have: ";
    double number_of_variables_in_reorder;
    std::cin >> number_of_variables_in_reorder;
    for (size_t k = 0; k < number_of_variables_in_reorder; ++k) {
        std::cout << "input the" << k+1 << "variable" << std::endl;
        std::string temp_input;
        double temp_Val;
        std::cin >> temp_input;
        std::cin >> temp_Val;
        equation_variables_from_user[temp_input] = temp_Val;
    }

    for (const auto& pair : equation_variables_from_user) {     //this was a snippet frm a chat gpt example code on maps lol...
        std::cout << pair.first << ": " << pair.second << "\n";
    } 
    
    std::cin.ignore();
    std::string reordered_mission_equation;
    std::cout << "Provide the formula to calculate the max mission score: ";
    std::getline(std::cin, reordered_mission_equation);

    // the code below is simular to the code above so mamybe just make a function to turn the user string into an actual expression since we will be doing this alot
    exprtk::symbol_table<double> mission_reo; //makes a table of the variables and what string they're associated with
    exprtk::expression<double> expression; //holds the string expression converted? empty but needs to exist so the parser has someplace to go
    exprtk::parser<double> parser; //th9is does the parsing turning the string into an actual expression
    for (const auto& pair : equation_variables_from_user) {  //goes thru every variable the user put in and adds it to the table generated by the sybol table
        mission_reo.add_variable(pair.first, const_cast<double&>(pair.second)); //this line does the physical adding
    }

    expression.register_symbol_table(mission_reo);  //tells the expression where they're able to pull the values from

    if (parser.compile(reordered_mission_equation, expression)) { // checks if it comiples or like is the formula the user put in valid
        double total_score = expression.value(); //evaluates it 
        std::cout << "\nTotal Mission Score: " << total_score << std::endl;
    }
    else {
        std::cout << "\nInvalid formula. Please check your syntax." << std::endl;
    }
}
int main()
{
    find_eq_vars();
    auto start = std::chrono::high_resolution_clock::now();

    //end t
    auto end = std::chrono::high_resolution_clock::now();

    //duration
    std::chrono::duration<double, std::milli> duration = end - start;

    std::cout << "Execution time: " << duration.count() << " ms\n";
    return 0;
}
